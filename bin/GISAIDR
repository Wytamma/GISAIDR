#!/usr/bin/env Rscript

suppressPackageStartupMessages(require(optparse))
suppressPackageStartupMessages(require(GISAIDR))

DATABASES  <- c("EpiCoV", "EpiPox", "EpiRSV")
VERSION    <- paste(packageVersion("GISAIDR"))
DATE_REGEX <- "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"

option_list = list(
    make_option(
        c("--aa-substitution"),
        action="store",
        default=NA,
        type='character',
        help="Query the database for amino acid substitutions."
    ),
    make_option(
        c("--accessions"),
        action="store",
        default=NA,
        type='character',
        help="Path to a txt file of GISAID accessions, new-line separated."
    ),
    make_option(
        c("--augur-input"),
        action="store_true",
        default=FALSE,
        help="Download augur input sequences and metadata."
    ),
    make_option(
        c("--batch"),
        action="store",
        default=1000,
        type='integer',
        help="Batch size when downloading sequences and metadata."
    ),
    make_option(
        c("--collection-date-complete"),
        action="store_true",
        default=FALSE,
        help="Include only entries with complete collection date."
    ),
    make_option(
        c("--complete"),
        action="store_true",
        default=FALSE,
        help="Include only complete entries."
    ),
    make_option(
        c("--credentials"),
        action="store",
        default=NA,
        type='character',
        help="Path to yaml file with GISAID credentials. Required If GISAIDR_USERNAME and GISAIDR_PASSWORD are not defined as environment variables:\n
            \tGISAIDR_USERNAME: \"yourUsername\"
            \tGISAIDR_PASSWORD: \"yourPassword\""
        ),
    make_option(
        c("--database"),
        action="store",
        default=NA,
        type='character',
        help= paste0("[REQUIRED] GISAID database name ( ", paste(DATABASES, collapse=", "), " ).")
    ),
    make_option(
        c("--dates-and-location"),
        action="store_true",
        default=FALSE,
        help="Download dates and location metadata."
    ),
    make_option(
        c("--debug"),
        action="store_true",
        default=FALSE,
        help="Enable debugging output."
    ),
    make_option(
        c("--from"),
        action="store",
        default=NA,
        type='character',
        help="Restrict queries to a collection date on or after this date."
    ),
    make_option(
        c("--from-subm"),
        action="store",
        default=NA,
        type='character',
        help="Restrict queries to a submission date on or after this date."
    ),
    make_option(
        c("--high-coverage"),
        action="store_true",
        default=FALSE,
        help="Include only high-coverage entries."
    ),
    make_option(
        c("--lineage"),
        action="store",
        default=NA,
        type='character',
        help="Query for a particular lineage. For EpiPox, it must also include the clade:\n
        \tEpiCoV: --lineage 'KP.3.1'
        \tEpiPox: --lineage 'IIb A.1'"
    ),
    make_option(
        c("--location"),
        action="store",
        default=NA,
        type='character',
        help="Restrict queries to a location."
    ),
    make_option(
        c("--low-coverage-excl"),
        action="store_true",
        default=FALSE,
        help="Exclude low coverage entries."
    ),
    make_option(
        c("--max-records"),
        action="store",
        default=NA,
        type='integer',
        help="Limit the number of records to the first N in the query."
    ),
    make_option(
        c("--nucl-mutation"),
        action="store",
        default=NA,
        type='character',
        help="Query the database for nucleotide mutations."
    ),
    make_option(
        c("--order-by"),
        action="store",
        default=NA,
        type='character',
        help="Order the final metadata by this column. Note: sequences will not follow this order."
    ),
    make_option(
        c("--order-by-rev"),
        action="store_true",
        default=FALSE,
        help="Reverse the order of the final metadata."
    ),
    make_option(
        c("--patient-status"),
        action="store_true",
        default=FALSE,
        help="Download patient status metadata."
    ),
    make_option(
        c("--prefix"),
        action="store",
        default=NA,
        type='character',
        help="Optional prefix for output files. If not provided, metadata will be saved to 'metadata.tsv' and sequences to 'sequences.fasta'."
    ),
    make_option(
        c("--retries"),
        action="store",
        default=2,
        type='integer',
        help="If an error is encountered, retry this number of times before exiting."
    ),
    make_option(
        c("--sequences"),
        action="store_true",
        default=FALSE,
        help="Download nucleotide sequences."
    ),
    make_option(
        c("--sequencing-technology"),
        action="store_true",
        default=FALSE,
        help="Download sequencing technology metadata."
    ),
    make_option(
        c("--subtype"),
        action="store",
        default=NA,
        type='character',
        help="Query the EpiRSV database for a particular subtype."
    ),
    make_option(
        c("--text"),
        action="store",
        default=NA,
        type='character',
        help="Path to a txt file for plain text searches."
    ),
    make_option(
        c("--to"),
        action="store",
        default=NA,
        type='character',
        help="Restrict queries to a collection date on or before this date."
    ),
    make_option(
        c("--to-subm"),
        action="store",
        default=NA,
        type='character',
        help="Restrict queries to a submission date on or before this date."
    ),
    make_option(
        c("--variant"),
        action="store",
        default=NA,
        type='character',
        help="Query the EpiCoV database for a particular variant."
    ),
    make_option(
        c("--verbosity"),
        action="store",
        default=1,
        type="integer",
        help="Set verbosity level of logging (ex. '--verbosity 1', '--verbosity 2')."
    ),
    make_option(
        c("--version"),
        action="store_true",
        default=FALSE,
        help="Display the GISAIDR version."
    ),
    make_option(
        c("--virus-name"),
        action="store",
        default=NA,
        type='character',
        help="Query the database for a virus name."
    )
)

opt = parse_args(OptionParser(option_list=option_list))

# -------------------------------------------------------------------------
# Parse arguments

args <- commandArgs(trailingOnly = TRUE)

if (length(args) == 0){
    print_help(OptionParser(option_list=option_list))
    quit(status=0)
}

if (opt$version){
    cat(paste0("GISAIDR v", VERSION, "\n"))
    quit(status=0)
}

if (opt$debug){
    Sys.setenv(GISAIDR_DEBUG = 1)
}
if (opt$verbosity){
    Sys.setenv(GISAIDR_VERBOSITY = opt$verbosity)
}

if (is.na(opt$database)){
    GISAIDR::log.error(paste("--database is required. Please provide a GISAID database name (", paste(DATABASES, collapse=", "), ")."))
    quit(status=1)
}

if (!"GISAIDR_USERNAME" %in% names(Sys.getenv()) && !"GISAIDR_PASSWORD" %in% names(Sys.getenv()) && is.na(opt$credentials)){
    GISAIDR::log.error("Missing credentials. Please define the environment variables:
    export GISAIDR_USERNAME='yourUsername'
    export GISAIDR_PASSWORD='yourPassword'

    Or provide a credentials.yml file with your GISAID username and password.\n
    GISAIDR_USERNAME: \"yourUsername\"
    GISAIDR_PASSWORD: \"yourPassword\"")
    quit(status=1)
}

if (!file.exists(opt$credentials)){
    GISAIDR::log.error(paste("--credentials file does not exist:", opt$credentials))
    quit(status=1)
}

if (!is.na(opt$text) && !file.exists(opt$text)){
    GISAIDR::log.error(paste("--text file does not exist:", opt$text))
    quit(status=1)
}

if (!is.na(opt$accessions) && !file.exists(opt$accessions)){
    GISAIDR::log.error(paste("--accessions file does not exist:", opt$accessions))
    quit(status=1)
}

if (!opt$database %in% DATABASES){
    GISAIDR::log.error(paste0("--database ", opt$database, " is not implemented in GISAIDR v", VERSION, ". Please select one of the following: ", paste(DATABASES, collapse=", ")))
    quit(status=1)
}

if (!is.na(opt$from) && !grepl(DATE_REGEX, opt$from)){
    GISAIDR::log.error(paste("--from", opt$from, "does not match the format YYYY-MM-DD."))
    quit(status=1)
}

if (!is.na(opt$to) && !grepl(DATE_REGEX, opt$to)){
    GISAIDR::log.error(paste("--from", opt$to, "does not match the format YYYY-MM-DD."))
    quit(status=1)
}

if (!is.na(opt$`from-subm`) && !grepl(DATE_REGEX, opt$`from-subm`)){
    GISAIDR::log.error(paste("--from-subm", opt$`from-subm`, "does not match the format YYYY-MM-DD."))
    quit(status=1)
}

if (!is.na(opt$`to-subm`) && !grepl(DATE_REGEX, opt$`to-subm`)){
    GISAIDR::log.error(paste("--to-subm", opt$`to-subm`, "does not match the format YYYY-MM-DD."))
    quit(status=1)
}

# if (!is.na(opt$lineage) && opt$database != "EpiCoV"){
#     GISAIDR::log.error(paste("--lineage", opt$lineage, "is only implemented for the EpiCoV database."))
#     quit(status=1)
# }

if (!is.na(opt$variant) && opt$database != "EpiCoV"){
    GISAIDR::log.error(paste("--variant", opt$variant, "is only implemented for the EpiCoV database."))
    quit(status=1)
}

if (!is.na(opt$text) && opt$database != "EpiCoV"){
    GISAIDR::log.error(paste("--text search is only available for the EpiCoV database. Maybe you would like to try an --accessions file?"))
    quit(status=1)
}

if (!is.na(opt$`nucl-mutation`) && opt$database != "EpiCoV"){
    GISAIDR::log.error(paste("--nucl-mutation is only available for the EpiCoV database."))
    quit(status=1)
}

if (!is.na(opt$subtype) && opt$database != "EpiRSV"){
    GISAIDR::log.error(paste("--subtype is only available for the EpiRSV database."))
    quit(status=1)
}

if (opt$`augur-input` && opt$database != "EpiCoV"){
    GISAIDR::log.error(paste("--augur-input is only available for the EpiCoV database."))
    quit(status=1)
}

# No output chosen
if (!opt$`augur-input` && !opt$`dates-and-location` && !opt$`patient-status` && !opt$`sequencing-technology` && !opt$sequences){
    GISAIDR::log.error(paste("At least one output must be selected from sequences and metadata, please see --help."))
    quit(status=1)
}

# -------------------------------------------------------------------------
# Input/Output

GISAIDR::log.info("Begin.")

# augur_input and sequences are redundant
if(opt$`augur-input` && opt$sequences){
    log.warn("Download types --augur-input and --sequences are redundant. Skipping separate sequences download.")
    opt$sequences <- FALSE
}

if (!is.na(opt$prefix)){ 
    metadata_file_path  <- paste0(opt$prefix, ".metadata.tsv")
    sequences_file_path <- paste0(opt$prefix, ".sequences.fasta")
} else {
    metadata_file_path  <- "metadata.tsv"
    sequences_file_path <- "sequences.fasta"
}

# Clean up existing output files, so we can continously write to them as we batch download
if (opt$`augur-input` || opt$`dates-and-location` || opt$`patient-status` || opt$`sequencing-technology`){
    if (file.exists(metadata_file_path)) {
        GISAIDR::log.info(paste("Removing existing metadata file:", metadata_file_path))
        invisible(file.remove(metadata_file_path))
    }
}
if (opt$`augur-input` || opt$sequences) {
    if (file.exists(sequences_file_path)) { 
        GISAIDR::log.info(paste("Removing existing sequences file:", sequences_file_path))
        invisible(file.remove(sequences_file_path)) 
    }
    # We're going to manually write to the sequences fasta as we process batches
    # To be determined if this is more/less efficient than other line writing methods    
    sequences_file <- file(sequences_file_path, open = "a")
}
if (opt$`augur-input`){
    augur_input_dir <- "gisaidr_augur_input_tmp"
    if (dir.exists(augur_input_dir)){
        GISAIDR::log.info(paste("Removing existing augur input directory:", augur_input_dir))
        unlink(augur_input_dir, recursive=TRUE)
    }
}

# -------------------------------------------------------------------------
# Authenticate with GISAID

if (!is.na(opt$credentials)){
    GISAIDR::log.info(paste("Reading GISAID credentials file:", opt$credentials))
    credentials <- yaml::read_yaml(opt$credentials)
    username    <- credentials$GISAIDR_USERNAME
    password    <- credentials$GISAIDR_PASSWORD
} else {
    username = Sys.getenv("GISAIDR_USERNAME")
    password = Sys.getenv("GISAIDR_PASSWORD")
}

GISAIDR::log.info(paste("Authenticating with GISAID database:", opt$database))
num_retries <- 0
while(num_retries <= opt$retries){
    num_retries <- num_retries + 1
    # if download fails, we'll log back in and update credentials
    tryCatch({
        credentials <- GISAIDR::login(username, password, opt$database)
        # Break out of the while loop of retries if successful
        break
    },
    # errors
    error=function(msg) {
        GISAIDR::log.error(msg)
        if (grepl("Server error", msg)){
            if (num_retries >= opt$retries){
                log.info(paste("Authentication failed, no retries remaining:", num_retries, "/", opt$retries))
                quit(status=1)
            }
            GISAIDR::log.info(paste("Authentication failed, retry:", num_retries, "/", opt$retries))
            return(credentials)
        } else {
            GISAIDR::log.error("Unhandled error, exiting.")
            quit(status=1)
        }
    })
}
credentials <- GISAIDR::login(username, password, opt$database)
GISAIDR::log.info("Authentication successful.")

# -------------------------------------------------------------------------
# Query

if (!is.na(opt$accessions)){
    log.info(paste("Reading GISAID accessions file:", opt$accessions))
    accession_ids <- readLines(opt$accessions)
} else {
    log.info(paste("Querying GISAID:", opt$database))

    # Dynamically create the query from the command-line arguments
    query_args <- c()
    query_args$fast <- TRUE
    query_args$credentials <- credentials
    if (!is.na(opt$location))                   { query_args$location   <- opt$location}
    if (!is.na(opt$from))                       { query_args$from       <- opt$from}
    if (!is.na(opt$to))                         { query_args$to         <- opt$to}
    if (!is.na(opt$`from-subm`))                { query_args$from_subm  <- opt$`from-subm`}
    if (!is.na(opt$`to-subm`))                  { query_args$to_subm    <- opt$`to-subm`}
    if (!is.na(opt$lineage))                    { query_args$lineage    <- opt$lineage}
    if (!is.na(opt$variant))                    { query_args$variant    <- opt$variant}
    if (!is.na(opt$subtype))                    { query_args$subtype    <- opt$subtype}
    if (!is.na(opt$`virus-name`))               { query_args$virus_name <- opt$`virus-name`}
    if (!is.na(opt$`aa-substitution`))          { query_args$aa_substitution <- opt$`aa-substitution`}
    if (!is.na(opt$`nucl-mutation`))            { query_args$nucl_mutation <- opt$`nucl-mutation`}
    if (!is.na(opt$`low-coverage-excl`))        { query_args$low_coverage_excl <- opt$`low-coverage-excl`}
    if (!is.na(opt$complete))                   { query_args$complete <- opt$complete}
    if (!is.na(opt$`high-coverage`))            { query_args$high_coverage <- opt$`high-coverage`}
    if (!is.na(opt$`collection-date-complete`)) { query_args$collection_date_complete <- opt$`collection-date-complete`}
    if (!is.na(opt$text))                       { query_args$text <- paste(readLines(opt$text), collapse = "\n") }

    suppressMessages(query_result <- do.call(GISAIDR::query, as.list(query_args)))

    # Sort by accession id (newest submissions to oldest)
    query_result$accession_id <- sort(query_result[["accession_id"]], decreasing = TRUE)
    accession_ids <- query_result[["accession_id"]]
}

log.info(paste("Found", length(accession_ids), "records."))

if (!is.na(opt$`max-records`) && opt$`max-records` >= 0){
    log.info(paste0("Restricting the number of records to --max-records ", opt$`max-records`, "."))
    accession_ids <- head(accession_ids, n=opt$`max-records`)
}
if (length(accession_ids) == 0 ){
    GISAIDR::log.info("Done")
    quit(status=0)
}

# -------------------------------------------------------------------------
# Download

# iterate through the accessions in batch chunks
if (length(accession_ids) < opt$batch){ opt$batch <- length(accession_ids)}
total_batches <- ceiling(length(accession_ids) / opt$batch)
num_batches   <- 0

GISAIDR::log.info(paste0("Downloading ", total_batches, " batch(es) of size ", opt$batch, "."))

for(start in seq(1, length(accession_ids), opt$batch)){

    num_batches <- num_batches + 1

    # Figure out our batch size for the current iteration
    end <- start + opt$batch - 1
    if (end > length(accession_ids)){end <- length(accession_ids)}
    GISAIDR::log.info(paste("Batch:", num_batches, "/", total_batches))
    batch_accession_ids <- accession_ids[start:end]

    num_retries <- 0
    while(num_retries <= opt$retries){

        num_retries <- num_retries + 1
        # if download fails, we'll log back in and update credentials
        credentials <- tryCatch({
            # Configure download args and types
            download_args <- c()
            download_args$credentials           <- credentials
            download_args$list_of_accession_ids <- batch_accession_ids

            download_types <- c()
            if (opt$`dates-and-location`   ){ download_types <- c(download_types, "dates_and_location") }
            if (opt$`patient-status`       ){ download_types <- c(download_types, "patient_status") }
            if (opt$`sequencing-technology`){ download_types <- c(download_types, "sequencing_technology") }
            if (opt$`augur-input`          ){ download_types <- c(download_types, "augur_input") }
            if (opt$`sequences`            ){ download_types <- c(download_types, "sequences") }

            for (download_type in download_types){ download_args[[download_type]] <- TRUE }

            # Download files
            download_results <- do.call(GISAIDR::download_files, as.list(download_args))

            # Merge metadata files
            metadata  <- NULL            
            for (download_type in download_types){

                if (download_type == "sequences"){ next }
                result <- download_results[[download_type]]
                if (download_type == "augur_input"){
                    df <- result$metadata
                    join_col <- "gisaid_epi_isl"
                } else {
                    df <- result
                    join_col <- "Accession ID"
                }
                if (is.null(metadata)){
                    metadata <- df
                } else {
                    cols <- unique(c(join_col, colnames(df)[!colnames(df) %in% colnames(metadata)]))
                    metadata <- merge(metadata, df[cols], by.x="Accession ID", by.y = join_col)
                }
            }
            # Write merged metadata
            if (!is.null(metadata)){
                # Put newest submissions first if possible
                if ("gisaid_epi_isl" %in% colnames(metadata)){ order_by <- "gisaid_epi_isl" } 
                else { order_by <- "Accession ID"}
                metadata <- metadata[order(metadata[[order_by]], decreasing=TRUE), ]
                # Append to output file
                suppressWarnings(write.table(
                    metadata, 
                    metadata_file_path,
                    row.names = FALSE, 
                    quote = FALSE, 
                    sep = "\t", 
                    col.names = !file.exists(metadata_file_path), 
                    append = TRUE
                ))
            }

            # Write sequences to file, either from --sequences or --augur-input
            sequences <- NULL
            if (!is.null(download_results$sequences)){
                sequences <- download_results$sequences
            } else if (!is.null(download_results$augur) && !is.null(download_results$augur$sequences)){
                sequences <- download_results$augur$sequences
            }
            if (!is.null(sequences)){
                cat(sequences, file=sequences_file, append=TRUE)
            }            

            # Break out of the while loop of download retries, continue on to next batch
            break
        },
        # errors
        error=function(msg) {
            GISAIDR::log.error(msg)
            if (grepl("Please login again", msg)){
                if (num_retries >= opt$retries){
                    log.info(paste("Download failed, no retries remaining:", num_retries, "/", opt$retries))
                    quit(status=1)
                }
                GISAIDR::log.info(paste("Download failed, retry:", num_retries, "/", opt$retries))
                GISAIDR::log.info(paste("Re-Authenticating with GISAID:", opt$database))
                credentials <- GISAIDR::login(username, password, opt$database)
                return(credentials)
            } else {
                GISAIDR::log.error("Unhandled error, exiting.")
                quit(status=1)
            }
        })
    }
}

if (!is.na(opt$`order-by`)){
    GISAIDR::log.info(paste("Ordering metadata by column:", opt$`order-by`))
    metadata <- metadata <- read.csv(metadata_file_path, sep="\t", quote="", check.names=FALSE)
    metadata <- metadata[order(metadata[[opt$`order-by`]], decreasing=opt$`order-by-rev`), ]
    write.table(metadata, metadata_file_path, row.names = FALSE, quote = FALSE, sep = "\t")
}

if (opt$`augur-input` || opt$sequences) {
    close(sequences_file)
}

GISAIDR::log.info("Done")
