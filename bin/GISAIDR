#!/usr/bin/env Rscript

suppressPackageStartupMessages(require(optparse))
suppressPackageStartupMessages(require(GISAIDR))

DATABASES  <- c("EpiCoV", "EpiPox", "EpiRSV")
VERSION    <- paste(packageVersion("GISAIDR"))
DATE_REGEX <- "^[0-9]{4}-[0-9]{2}-[0-9]{2}$"

option_list = list(
    make_option(
        c("--database"),
        action="store",
        default=NA,
        type='character',
        help= paste0("[REQUIRED] GISAID database name ( ", paste(DATABASES, collapse=", "), " ).")
    ),
    make_option(
        c("--credentials"),
        action="store",
        default=NA,
        type='character',
        help="Path to yaml file with GISAID credentials. Required If GISAIDR_USERNAME and GISAIDR_PASSWORD are not defined as environment variables:\n
            \tGISAIDR_USERNAME: \"yourUsername\"
            \tGISAIDR_PASSWORD: \"yourPassword\""
        ),
    make_option(
        c("--metadata"),
        action="store",
        default=NA,
        type='character',
        help="Output path for metadata. If not provided, metadata will not be written."
    ),
    make_option(
        c("--sequences"),
        action="store",
        default=NA,
        type='character',
        help="Output path for sequences. If not provided, sequences will not be written."
    ),
    make_option(
        c("--aa-substitution"),
        action="store",
        default=NA,
        type='character',
        help="Query the database for amino acid substitutions."
    ),
    make_option(
        c("--batch"),
        action="store",
        default=1000,
        type='integer',
        help="Batch size when downloading sequences and metadata."
    ),
    make_option(
        c("--collection-date-complete"),
        action="store_true",
        default=FALSE,
        help="Include only entries with complete collection date."
    ),
    make_option(
        c("--complete"),
        action="store_true",
        default=FALSE,
        help="Include only complete entries."
    ),
    make_option(
        c("--from"),
        action="store",
        default=NA,
        type='character',
        help="Restrict queries to a collection date on or after this date."
    ),
    make_option(
        c("--from-subm"),
        action="store",
        default=NA,
        type='character',
        help="Restrict queries to a submission date on or after this date."
    ),
    make_option(
        c("--high-coverage"),
        action="store_true",
        default=FALSE,
        help="Include only high-coverage entries."
    ),
    make_option(
        c("--lineage"),
        action="store",
        default=NA,
        type='character',
        help="Query the EpiCoV database for a particular lineage."
    ),
    make_option(
        c("--location"),
        action="store",
        default=NA,
        type='character',
        help="Restrict queries to a location."
    ),
    make_option(
        c("--low-coverage-excl"),
        action="store_true",
        default=FALSE,
        help="Exclude low coverage entries."
    ),
    make_option(
        c("--max-records"),
        action="store",
        default=NA,
        type='integer',
        help="Limit the number of records to the first N in the query."
    ),
    make_option(
        c("--nucl-mutation"),
        action="store",
        default=NA,
        type='character',
        help="Query the database for nucleotide mutations."
    ),
    make_option(
        c("--retries"),
        action="store",
        default=3,
        type='integer',
        help="If a download error is encountered, retry this number of times before exiting."
    ),
    make_option(
        c("--text"),
        action="store",
        default=NA,
        type='character',
        help="Path to a txt file for plain text searches."
    ),
    make_option(
        c("--to"),
        action="store",
        default=NA,
        type='character',
        help="Restrict queries to a collection date on or before this date."
    ),
    make_option(
        c("--to-subm"),
        action="store",
        default=NA,
        type='character',
        help="Restrict queries to a submission date on or before this date."
    ),
    make_option(
        c("--variant"),
        action="store",
        default=NA,
        type='character',
        help="Query the EpiCoV database for a particular variant."
    ),
    make_option(
        c("--virus-name"),
        action="store",
        default=NA,
        type='character',
        help="Query the database for a virus name."
    ),
    make_option(
        c("--debug"),
        action="store_true",
        default=FALSE,
        help="Enable debugging output."
    ),
    make_option(
        c("-v", "--version"),
        action="store_true",
        default=FALSE,
        help="Display the GISAIDR version."
    )
)

opt = parse_args(OptionParser(option_list=option_list))

# -------------------------------------------------------------------------
# Parse arguments

args <- commandArgs(trailingOnly = TRUE)

if (length(args) == 0){
    print_help(OptionParser(option_list=option_list))
    quit(status=0)
}

if (opt$version){
    cat(paste0("GISAIDR v", VERSION, "\n"))
    quit(status=0)
}

if (opt$debug){
    Sys.setenv(GISAIDR_DEBUG = 1)
}

if (is.na(opt$database)){
    message(paste0(Sys.time(), "\tERROR: --database is required. Please provide a GISAID database name (ex. '--database EpiPox', '--database EpiCoV')\n"))
    quit(status=1)
}

if (!"GISAIDR_USERNAME" %in% names(Sys.getenv()) && !"GISAIDR_PASSWORD" %in% names(Sys.getenv()) && is.na(opt$credentials)){
    message(paste0(Sys.time(), "\tERROR: Missing credentials. Please define the environment variables:
    export GISAIDR_USERNAME='yourUsername'
    export GISAIDR_PASSWORD='yourPassword'

    Or provide a credentials.yml file with your GISAID username and password.\n
    GISAIDR_USERNAME: \"yourUsername\"
    GISAIDR_PASSWORD: \"yourPassword\"\n"))
    quit(status=1)
}

if (!file.exists(opt$credentials)){
    message(paste0(Sys.time(), "\tERROR: --credentials file does not exist: ", opt$credentials, "\n"))
    quit(status=1)
}

if (!is.na(opt$text) && !file.exists(opt$text)){
    message(paste0(Sys.time(), "\tERROR: --text file does not exist: ", opt$text, "\n"))
    quit(status=1)
}

if (!opt$database %in% DATABASES){
    message(paste0(Sys.time(), "\tERROR: --database ", opt$database, " is not implemented in GISAIDR v", VERSION, ". Please select one of the following: ", paste(DATABASES, collapse=", "), "\n" ))
    quit(status=1)
}

if (!is.na(opt$from) && !grepl(DATE_REGEX, opt$from)){
    message(paste0(Sys.time(), "\tERROR: --from ", opt$from, " does not match the format YYYY-MM-DD.", "\n" ))
    quit(status=1)
}

if (!is.na(opt$to) && !grepl(DATE_REGEX, opt$to)){
    message(paste0(Sys.time(), "\tERROR: --from ", opt$to, " does not match the format YYYY-MM-DD.", "\n" ))
    quit(status=1)
}

if (!is.na(opt$`from-subm`) && !grepl(DATE_REGEX, opt$`from-subm`)){
    message(paste0(Sys.time(), "\tERROR: --from-subm ", opt$`from-subm`, " does not match the format YYYY-MM-DD.", "\n" ))
    quit(status=1)
}

if (!is.na(opt$`to-subm`) && !grepl(DATE_REGEX, opt$`to-subm`)){
    message(paste0(Sys.time(), "\tERROR: --to-subm ", opt$`to-subm`, " does not match the format YYYY-MM-DD.", "\n" ))
    quit(status=1)
}

if (!is.na(opt$lineage) && opt$database != "EpiCoV"){
    message(paste0(Sys.time(), "\tERROR: --lineage ", opt$lineage, " is only implemented for the EpiCoV database", "\n" ))
    quit(status=1)
}

if (!is.na(opt$variant) && opt$database != "EpiCoV"){
    message(paste0(Sys.time(), "\tERROR: --variant ", opt$variant, " is only implemented for the EpiCoV database", "\n" ))
    quit(status=1)
}

if (is.na(opt$metadata) && is.na(opt$sequences)){
    message(paste0(Sys.time(), "\tERROR: Either --metadata or --sequences should be supplied.", "\n" ))
    quit(status=1)
}

# -------------------------------------------------------------------------
# Input/Output

message(paste0(Sys.time(), "\tBegin."))

# Clean up existing output files, so we can continously write to them as we batch download
if (!is.na(opt$metadata) && file.exists(opt$metadata)) {
    invisible(file.remove(opt$metadata))
}
if (!is.na(opt$sequences)){

    # We're going to manually write to the sequences fasta as we process batches
    # To be determined if this is more/less efficient than other line writing methods
    if (file.exists(opt$sequences)){ invisible(file.remove(opt$sequences)) }
    sequences_file <- file(opt$sequences, open = "a")
}

# -------------------------------------------------------------------------
# Authenticate with GISAID

if (!is.na(opt$credentials)){
    message(paste0(Sys.time(), " \tReading GISAID credentials from ", opt$credentials))
    credentials <- yaml::read_yaml(opt$credentials)
    username    <- credentials$GISAIDR_USERNAME
    password    <- credentials$GISAIDR_PASSWORD
} else {
    username = Sys.getenv("GISAIDR_USERNAME")
    password = Sys.getenv("GISAIDR_PASSWORD")
}

message(paste0(Sys.time(), " \tAuthenticating with GISAID ", opt$database, "."))
credentials <- GISAIDR::login(username, password, opt$database)
message(paste0(Sys.time(), " \tAuthentication successful."))

# -------------------------------------------------------------------------
# Query

message(paste0(Sys.time(), " \tQuerying GISAID ", opt$database, "."))

# Dynamically create the query from the command-line arguments
query_args <- c()
query_args$fast <- TRUE
query_args$credentials <- credentials
if (!is.na(opt$location))                   { query_args$location   <- opt$location}
if (!is.na(opt$from))                       { query_args$from       <- opt$from}
if (!is.na(opt$to))                         { query_args$to         <- opt$to}
if (!is.na(opt$`from-subm`))                { query_args$from_subm  <- opt$`from-subm`}
if (!is.na(opt$`to-subm`))                  { query_args$to_subm    <- opt$`to-subm`}
if (!is.na(opt$lineage))                    { query_args$lineage    <- opt$lineage}
if (!is.na(opt$variant))                    { query_args$variant    <- opt$variant}
if (!is.na(opt$`virus-name`))               { query_args$virus_name <- opt$`virus-name`}
if (!is.na(opt$`aa-substitution`))          { query_args$aa_substitution <- opt$`aa-substitution`}
if (!is.na(opt$`nucl-mutation`))            { query_args$nucl_mutation <- opt$`nucl-mutation`}
if (!is.na(opt$`low-coverage-excl`))        { query_args$low_coverage_excl <- opt$`low-coverage-excl`}
if (!is.na(opt$complete))                   { query_args$complete <- opt$complete}
if (!is.na(opt$`high-coverage`))            { query_args$high_coverage <- opt$`high-coverage`}
if (!is.na(opt$`collection-date-complete`)) { query_args$collection_date_complete <- opt$`collection-date-complete`}
if (!is.na(opt$text))                       { query_args$text <- paste(readLines(opt$text), collapse = "\n") }

suppressMessages(query_result <- do.call(GISAIDR::query, as.list(query_args)))

message(paste0(Sys.time(), " \tFound ", nrow(query_result), " records."))
# Sort by accession id (newest submissions to oldest)
query_result$accession_id <- sort(query_result[["accession_id"]], decreasing = TRUE)

if (!is.na(opt$`max-records`) && opt$`max-records` >= 0){
    message(paste0(Sys.time(), " \tRestricting the number of records to --max-records ", opt$`max-records`))
    query_result <- head(query_result, opt$`max-records`)
}

accession_ids <- query_result[["accession_id"]]

# -------------------------------------------------------------------------
# Download

# iterate through the accessions in batch chunks
total_batches <- ceiling(length(accession_ids) / opt$batch)
num_batches   <- 0

message(paste0(Sys.time(), " \tDownloading ", total_batches, " batch(es) of size ", opt$batch, "."))

for(start in seq(1, length(accession_ids), opt$batch)){

    num_batches <- num_batches + 1

    # Figure out our batch size for the current iteration
    end <- start + opt$batch - 1
    if (end > length(accession_ids)){end <- length(accession_ids)}
    message(paste0(Sys.time(), " \tBatch: ", num_batches, " / ", total_batches))
    batch_accession_ids <- accession_ids[start:end]

    num_retries <- 0
    while(num_retries < opt$retries){

        num_retries <- num_retries + 1
        # if download fails, we'll log back in and update credentials
        credentials <- tryCatch(
        # try
        {
            # Download from GISAID
            download_args <- c()
            download_args$credentials           <- credentials
            download_args$list_of_accession_ids <- batch_accession_ids
            if (is.na(opt$sequences)) { download_args$get_sequence=FALSE }
            batch_result <- do.call(GISAIDR::download, as.list(download_args))

            # Put newest submissions first in this batch
            metadata <- batch_result[order(batch_result$accession_id, decreasing=TRUE), ]

            # Write sequences to file
            if (!is.na(opt$sequences)){
                fasta_records <- unlist(lapply(seq(1, nrow(metadata)), function(row_i){
                    header  <- paste0(">", batch_result[row_i, "strain"])
                    sequence <- paste0(batch_result[row_i, "sequence"])
                    record <- paste0(header, "\n", sequence)
                }))
                fasta = paste(fasta_records, collapse="\n")
                # Undetermined if this method of manually appending a large number of
                # lines to a file is more efficient.
                cat(fasta, file= sequences_file, append=TRUE, sep="\n")
            }

            # Write metadata to file
            if (!is.na(opt$metadata)){
                # remove the sequence column
                if (!is.na(opt$sequences)){ metadata <- subset(metadata, select = -c(sequence)) }
                write.table(metadata, opt$metadata, row.names = FALSE, quote = FALSE, sep = "\t", col.names = !file.exists(opt$metadata), append = TRUE)
            }
            # Break out of the tryCatch block, continue to next batch
            break
        },
        # errors
        error=function(msg) {
            message(msg)
            if (grepl("Please login again", msg)){
            message(paste0(Sys.time(), " \t\tDownload failed, retry ", num_retries, " / ", opt$retries))
            message(paste0(Sys.time(), " \tRe-Authenticating with GISAID ", opt$database, "."))
            credentials <- GISAIDR::login(username, password, database)
            return(credentials)
            }
        }
        )
    }
}

if (!is.na(opt$sequences)){
    close(sequences_file)
}

message(paste0(Sys.time(), "\tDone."))
